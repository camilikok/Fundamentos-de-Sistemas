ChatGPT dijo:
Memoria guardada actualizada
Â¡Claro! AquÃ­ tienes una recopilaciÃ³n de apuntes amplia, bien estructurada y lista para copiar en GitHub, perfecta como material de estudio a largo plazo. Incluye definiciones, estructuras, conceptos clave, algoritmos y ejemplos, incluyendo tambiÃ©n recursividad al final.

ğŸ§  Apuntes de Estructuras de Datos â€“ Grafos, Recorridos y Recursividad
ğŸ“˜ 1. IntroducciÃ³n a los Grafos
Un grafo es una estructura de datos no lineal que representa relaciones entre pares de elementos.

ğŸ§± Componentes:
VÃ©rtice (nodo): Representa una entidad (ciudad, persona, estaciÃ³n, etc.)

Arista (conexiÃ³n): Une dos vÃ©rtices. Puede tener direcciÃ³n o peso.

ğŸ“‚ Tipos de grafos:
Dirigido: Las aristas tienen direcciÃ³n (v1 â†’ v2)

No dirigido: Las aristas no tienen direcciÃ³n (v1 â€” v2)

Ponderado: Las aristas tienen un valor numÃ©rico (peso/costo/distancia)

No ponderado: Todas las conexiones tienen peso igual o nulo

ğŸ“Š Propiedades:
Grado de un nodo:

No dirigido: nÃºmero total de aristas conectadas

Dirigido:

Grado de entrada (in-degree): nÂº de aristas que llegan

Grado de salida (out-degree): nÂº de aristas que salen

Camino: Secuencia de nodos conectados por aristas

Ciclo: Camino que inicia y termina en el mismo nodo

Adyacencia: RelaciÃ³n directa entre nodos conectados

ğŸ—‚ï¸ 2. RepresentaciÃ³n de Grafos
ğŸ”¹ Matriz de adyacencia:
java
Copiar
Editar
int[][] grafo = new int[nodos][nodos];
Ãštil para grafos densos (muchas conexiones)

grafo[i][j] = 1 si hay conexiÃ³n entre i y j

ğŸ”¹ Lista de adyacencia:
java
Copiar
Editar
List<List<Integer>> grafo = new ArrayList<>();
Mejor para grafos dispersos (pocas conexiones)

ğŸ” 3. Recorridos en Grafos
ğŸ”¸ DFS (Depth-First Search)
Explora lo mÃ¡s profundo posible antes de retroceder

Usa pila o recursiÃ³n

java
Copiar
Editar
void dfs(int nodo) {
    visitado[nodo] = true;
    for (int vecino : grafo[nodo]) {
        if (!visitado[vecino]) {
            dfs(vecino);
        }
    }
}
ğŸ”¸ BFS (Breadth-First Search)
Recorre el grafo por niveles

Usa cola (FIFO)

java
Copiar
Editar
void bfs(int inicio) {
    Queue<Integer> cola = new LinkedList<>();
    visitado[inicio] = true;
    cola.add(inicio);

    while (!cola.isEmpty()) {
        int actual = cola.poll();
        for (int vecino : grafo[actual]) {
            if (!visitado[vecino]) {
                visitado[vecino] = true;
                cola.add(vecino);
            }
        }
    }
}
ğŸ“ 4. Algoritmos de Ruta MÃ¡s Corta
âœ… Dijkstra
Encuentra la ruta mÃ¡s corta desde un nodo a todos los demÃ¡s

Solo funciona con pesos positivos

java
Copiar
Editar
PriorityQueue<Par> pq = new PriorityQueue<>();
pq.add(new Par(origen, 0));
dist[origen] = 0;

while (!pq.isEmpty()) {
    Par actual = pq.poll();
    for (Par vecino : grafo.get(actual.nodo)) {
        int nuevaDist = dist[actual.nodo] + vecino.peso;
        if (nuevaDist < dist[vecino.nodo]) {
            dist[vecino.nodo] = nuevaDist;
            pq.add(new Par(vecino.nodo, nuevaDist));
        }
    }
}
âœ… A* (A estrella)
Usa heurÃ­stica para optimizar bÃºsqueda

FÃ³rmula: f(n) = g(n) + h(n)

g(n): costo real desde inicio hasta n

h(n): estimaciÃ³n (heurÃ­stica) desde n al objetivo

f(n): costo estimado total del camino

ğŸ“¦ 5. Estructuras de Datos Relacionadas
ğŸ”¹ Pilas (Stacks)
LIFO: Last In, First Out

java
Copiar
Editar
Stack<Integer> pila = new Stack<>();
pila.push(5);    // insertar
pila.pop();      // eliminar tope
pila.peek();     // ver tope
ğŸ”¹ Colas (Queues)
FIFO: First In, First Out

java
Copiar
Editar
Queue<Integer> cola = new LinkedList<>();
cola.add(5);     // insertar
cola.poll();     // eliminar primero
cola.peek();     // ver primero
ğŸ”„ 6. Recursividad
ğŸ§  Â¿QuÃ© es?
Un algoritmo recursivo es aquel que se llama a sÃ­ mismo para resolver subproblemas mÃ¡s pequeÃ±os del problema original.

ğŸ§± Estructura bÃ¡sica:
java
Copiar
Editar
tipo funcion(tipo parametro) {
    if (caso_base) {
        return resultado;
    } else {
        return funcion(caso_mas_pequeno);
    }
}
âœ… CaracterÃ­sticas:
Caso base claro (cuando termina)

Llamada a sÃ­ misma con una versiÃ³n reducida del problema

Puede causar StackOverflow si no se detiene

ğŸ”¢ Ejemplo: Factorial
java
Copiar
Editar
int factorial(int n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}
ğŸ“Š Ejemplo: Fibonacci
java
Copiar
Editar
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);
}
ğŸ§  Ventajas vs Desventajas:
Ventajas	Desventajas
CÃ³digo mÃ¡s limpio	MÃ¡s uso de memoria
Ideal para estructuras recursivas	Menor eficiencia (sin memoizaciÃ³n)
Facilita algunos problemas	Puede causar StackOverflow

ğŸ“š 7. Ejercicios tÃ­picos en universidades
âœ… Casos comunes:
Red social: Usuarios (nodos), amistad (aristas)

Red de computadoras: Conexiones con latencia

Sistema de transporte: Estaciones (nodos), rutas con tiempo (pesos)

Mapa de ciudades: Ciudades y carreteras con distancias

Rutas de vuelo: Aeropuertos conectados con vuelos y costos

ğŸ”— 8. Consejos para exÃ¡menes
Saber cuÃ¡ndo usar lista o matriz de adyacencia

Poder hacer BFS/DFS â€œa manoâ€ en papel

Explicar Dijkstra y aplicar tabla de distancias

Memorizar f(n) = g(n) + h(n) de A*

Diferenciar pila y cola

No olvidar caso base en recursiÃ³n
